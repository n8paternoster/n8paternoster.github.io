<!DOCTYPE html>

<html lang="en" xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta charset="utf-8" />
    <title>Nathan Paternoster | Project Euler Problem 93</title>
    <link rel="icon" type="image/x-icon" href="/images/favicon.ico">
    <link rel="stylesheet" type="text/css" href="/css/nate.css" />
    <link rel="stylesheet" type="text/css" href="/css/projects.css" />
    <noscript><link rel="stylesheet" type="text/css" href="/css/no-js.css" /></noscript>
    <script src="/js/nate.js" defer></script>
    <script src="https://kit.fontawesome.com/254df2922f.js" crossorigin="anonymous"></script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
    <div id="page-wrapper">

        <!-- Top navigation bar -->
        <ul class="topnav">
            <li><a href="/index.html">Nathan Paternoster</a></li>
            <li><a href="/coursework.html">Coursework</a></li>
            <li><a href="/projects.html">Projects</a></li>
            <li><a href="/recordings.html">Recordings</a></li>
            <li><a href="/contact.html">Contact</a></li>
        </ul>

        <!-- Page content -->
        <div class="content">
            <div class="euler-problem-link-container">
                <a href="../euler.html" class="back-link"><i class="fas fa-arrow-left"></i>&nbsp;Back to Problems</a>
                <div class="euler-problem-links">
                    <a href="https://projecteuler.net/problem=93" target="_blank"><i class="fas fa-link"></i>&nbsp;Problem 93 on Project Euler</a>
                    <a href="https://github.com/n8paternoster/Project-Euler/blob/master/Problems/Sources/76-100/93.cpp" target="_blank"><i class="fas fa-code"></i>&nbsp;Problem 93 Code</a>
                </div>
            </div>
            <h1 id="euler-problem-title">Problem 93 - Arithmetic Expressions</h1>
            <div class="euler-problem-view">
                <button class="accordion" type="button">View problem</button>
                <div class="accordion-panel">
                    <blockquote cite="https://projecteuler.net/problem=93">
                        <p>By using each of the digits from the set, {1, 2, 3, 4}, exactly once, and making use of the four arithmetic operations (+, −, *, /) and brackets/parentheses, it is possible to form different positive integer targets.</p>
                        <p>For example,</p>
                        <p>
                            8 = (4 * (1 + 3)) / 2<br />
                            14 = 4 * (3 + 1 / 2)<br />
                            19 = 4 * (2 + 3) − 1<br />
                            36 = 3 * 4 * (2 + 1)
                        </p>
                        <p>Note that concatenations of the digits, like 12 + 34, are not allowed.</p>
                        <p>Using the set, {1, 2, 3, 4}, it is possible to obtain thirty-one different target numbers of which 36 is the maximum, and each of the numbers 1 to 28 can be obtained before encountering the first non-expressible number.</p>
                        <p>Find the set of four distinct digits, <i>a</i> &lt; <i>b</i> &lt; <i>c</i> &lt; <i>d</i>, for which the longest set of consecutive positive integers, 1 to <i>n</i>, can be obtained, giving your answer as a string: <i>abcd</i>.</p>
                    </blockquote>
                </div>
            </div>
            <hr />
            <section>
                <h2>Expression format</h2>
                <p>On first reading, this problem may seem almost hopelessly complex - there are so many different possible expressions. Although the problem's wording asks us to find target numbers (the results of expressions), it would be a mistake to approach the problem by trying to find an expression for a given target number. The key is to recognize that the number of expressions is low enough to obtain the answer by brute force.</p>
                <p>To count how many possible expressions there are, consider the possible variables. An expression has the following form:</p>
                <div class="mathjax-block">
                    <p><i>a</i> O<sub>1</sub> <i>b</i> O<sub>2</sub> <i>c</i> O<sub>3</sub> <i>d</i> = target</p><br />
                    <p>{<i>a</i>, <i>b</i>, <i>c</i>, <i>d</i>} are 4 distinct numbers in the range [1, 9].</p>
                    <p>{O<sub>1</sub>, O<sub>2</sub>, O<sub>3</sub>} are 3 arithmetic operators (+, &minus;, &times;, &divide;)</p>
                </div>
                <p>In addition, parentheses may be used anywhere. It turns out the number of different combinations of valid parentheses is given by the <a class="wiki-link-inline" href="https://en.wikipedia.org/wiki/Catalan_number" target="_blank">Catalan numbers</a>. The <i>n</i>th Catalan number gives the number of different ways <i>n</i>+1 terms can be parenthesized. The sequence of Catalan numbers begins 1, 1, 2, 5, 14, 42, ... With 4 terms, there are C<sub>4</sub> = 5 different ways to place parentheses on the above expression. Those ways are:</p>
                <div class="mathjax-block">
                    <p>((<i>a</i> + <i>b</i>) + <i>c</i>) + <i>d</i></p>
                    <p>(<i>a</i> + (<i>b</i> + <i>c</i>)) + <i>d</i></p>
                    <p><i>a</i> + ((<i>b</i> + <i>c</i>) + <i>d</i>)</p>
                    <p><i>a</i> + (<i>b</i> + (<i>c</i> + <i>d</i>))</p>
                    <p>(<i>a</i> + <i>b</i>) + (<i>c</i> + <i>d</i>)</p>
                </div>
                <p>With these we can calculate how many total expressions there are to evaluate:</p>
                <ul>
                    <li>Sets of 4 numbers (9 choose 4 = 126 sets) &times;</li>
                    <li>Permutations of a set (4! = 24 permutations) &times;</li>
                    <li>Arrangements of 3 operators (4<sup>3</sup> = 64 arrangements) &times;</li>
                    <li>Arrangements of parentheses (C<sub>4</sub> = 5 arrangements)</li>
                    <li>= <b>967,680 total expressions</b></li>
                </ul>
            </section>
            <section>
                <h2>Implementation</h2>
                <p>First I'll define the problem specifications:</p>
                <code>
                    <pre>
constexpr int maxNumber = 9;&#9;// starting from 1
constexpr int setSize = 4;&#9;&#9;// {a, b, c, d}
constexpr int numOpCodes = 4;
// 0 = addition
// 1 = subtraction
// 2 = multiplication
// 3 = division
constexpr int numParenthesesCodes = 5;
// 0 = ((ab)c)d
// 1 = (a(bc))d
// 2 = a(b(cd))
// 3 = a(b(cd))
// 4 = (ab)(cd)
constexpr int maxSolution = (maxNumber)*(maxNumber-1)*(maxNumber-2)*(maxNumber-3);</pre>
                </code>
                <p>I assign integer codes to represent each arithmetic operator and arrangement of parentheses. <samp>maxSolution</samp> is the highest possible target number reachable with the problem's specifications (declared <samp>constexpr</samp> to be used with std::array).</p>
                <p>I also define a couple of type aliases to simplify the code:</p>
                <code>
                    <pre>
#include &lt;array&gt;
#include &lt;tuple&gt;

using setArray_t = std::array&lt;float, setSize&gt;
using opArray_t = std::array&lt;int, setSize-1&gt;</pre>
                </code>
                <p>A <samp>setArray_t</samp> variable will hold the values of {<i>a</i>, <i>b</i>, <i>c</i>, <i>d</i>} and an <samp>opArray_t</samp> variable will hold the values of {O<sub>1</sub>, O<sub>2</sub>, O<sub>3</sub>}. Why is there a <samp>float</samp> in there? While the problem specifies integer set numbers and integer targets, we'll see later that non-integer numbers can (and must!) be used in the intermediate values calculated in the process of evaluating an expression.</p>
                <p>Next, helper functions to evaluate a given expression. First, a function to perform a single operation on two numbers:</p>
                <code>
                    <pre>
inline float calculate(float x, float y, int opCode, bool &valid) {
&#9;switch (opCode) {
&#9;&#9;case 0: return x + y;
&#9;&#9;case 1: return x - y;
&#9;&#9;case 2: return x * y;
&#9;&#9;case 3:
&#9;&#9;&#9;if ((y &gt; 0 ? (y &lt; 0.001f) : (y &gt; -0.001f))) {
&#9;&#9;&#9;&#9;// division by 0
&#9;&#9;&#9;&#9;valid = false;
&#9;&#9;&#9;&#9;return 0.0f;
&#9;&#9;&#9;} else return x / y;
&#9;}
&#9;valid = false;
&#9;return 0.0f;
}</pre>
                </code>
                <p>The <samp>valid</samp> flag will indicate if the result of the calculation can be considered valid. The only complication arises when a division by 0 is inputted. Since this function operates on floating-point numbers, an arbitrarily close approximation to 0 needs to be used instead of direct comparison.</p>
                <p>Then, <samp>evaluateExpression</samp> will calculate the result of a full expression:</p>
                <p>Then, <samp>evaluateExpression</samp> will calculate the result of a full expression:</p>
                <code>
                    <pre class="small-text">
int evaluateExpression(const setArray_t &numbers, const opArray_t &operations, int pCode, bool &valid) {
&#9;valid = true;
&#9;float result = 0;
&#9;switch (pCode) {
&#9;case 0:&#9;&#9;// ((a + b) + c) + d
&#9;&#9;result = calculate(numbers[0], numbers[1], operations[0], valid);
&#9;&#9;result = calculate(result, numbers[2], operations[1], valid);
&#9;&#9;result = calculate(result, numbers[3], operations[2], valid);
&#9;&#9;break;
&#9;case 1:&#9;&#9;// (a + (b + c)) + d
&#9;&#9;result = calculate(numbers[1], numbers[2], operations[1], valid);
&#9;&#9;result = calculate(numbers[0], result, operations[0], valid);
&#9;&#9;result = calculate(result, numbers[3], operations[2], valid);
&#9;&#9;break;
&#9;case 2:&#9;&#9;// a + ((b + c) + d)
&#9;&#9;result = calculate(numbers[1], numbers[2], operations[1], valid);
&#9;&#9;result = calculate(result, numbers[3], operations[2], valid);
&#9;&#9;result = calculate(numbers[0], result, operations[0], valid);
&#9;&#9;break;
&#9;case 3:&#9;&#9;// a + (b + (c + d))
&#9;&#9;result = calculate(numbers[2], numbers[3], operations[2], valid);
&#9;&#9;result = calculate(numbers[1], result, operations[1], valid);
&#9;&#9;result = calculate(numbers[0], result, operations[0], valid);
&#9;&#9;break;
&#9;case 4: {&#9;// (a + b) + (c + d) 
&#9;&#9;result = calculate(numbers[0], numbers[1], operations[0], valid);
&#9;&#9;float temp = calculate(numbers[2], numbers[3], operations[2], valid);
&#9;&#9;result = calculate(result, temp, operations[1], valid);
&#9;&#9;break;
&#9;}
&#9;default:
&#9;&#9;valid = false;
&#9;&#9;break;
&#9;}
&#9;int iResult = static_cast&lt;int&gt;(result);
&#9;if (iResult != result) valid = false;
&#9;return iResult;
}</pre>
                </code>
                <p>An invalid result from this function is one that does not produce an integer or contains a division by 0.</p>
                <h4>Generating all expressions</h4>
                <p>The four variables to iterate through are:</p>
                <ul>
                    <li>Sets of 4 numbers</li>
                    <li>Permutations of a set</li>
                    <li>Arrangements of 3 operators</li>
                    <li>Arrangements of parentheses</li>
                </ul>
                <p>The sets of numbers are specifically the combinations of 9 numbers taken 4 at a time (<sub>9</sub>C<sub>4</sub> = 126 combinations). To iterate through these 126 sets, I use a binary mask to represent numbers in a set. Indices in the mask correspond to numbers. For example,</p>
                <div class="mathjax-block">
                    <p>\(001101001\) (mask) &#10132; \(\{3, 4, 6, 9\}\)</p>
                </div>
                <p>Taking all the permutations of this mask generates all combinations of 4 numbers. The next few permutations are:</p>
                <div class="mathjax-block">
                    <p>...</p>
                    <p>\(001100110\) &#10132; \(\{3, 4, 7, 8\}\)</p>
                    <p>\(001100101\) &#10132; \(\{3, 4, 7, 9\}\)</p>
                    <p>\(001100011\) &#10132; \(\{3, 4, 8, 9\}\)</p>
                    <p>\(001011100\) &#10132; \(\{3, 5, 6, 7\}\)</p>
                    <p>...</p>
                </div>
                <p>Using std::fill to initialize the mask to 0111100000 (unused 0 index) and std::prev_permutation we can get all sets like so:</p>
                <code><pre>
#include &lt;array&gt;
#include &lt;algorithm&gt;

std::array&lt;bool, maxNumber+1&gt; mask = {};
std::fill(mask.begin()+1, mask.begin()+1+setSize, true);
do {
&#9;setArray_t set;
&#9;// read the mask
&#9;for (int i = 1, n = 0; i <= maxNumber; i++)
&#9;&#9;if (mask[i]) set[n++] = static_cast&lt;float&gt;(i);
&#9;// all sets
} while (std::prev_permutation(mask.begin()+1, mask.end()));</pre></code>
                <p>The permutations of each set can also be generated using the similar std::next_permutation:</p>
                <code><pre>
setArray_t set;
...
do {
&#9;// all permutations of a set
} while (std::next_permutation(set.begin(), set.end()));</pre></code>
                <p>However, arrangements of arithmetic operators can also include repeated operators. Assigning numbers to represent each operator as above, <samp>opCode</samp> represents the 3 operators in one expression:</p>
                <code><pre>
opArray_t opCode = {};&#9;// initialize to {0, 0, 0}</pre></code>
                <p>For example, {0, 3, 1} corresponds to <i>a</i>+<i>b</i>&divide;<i>c</i>&minus;<i>d</i> and {2, 2, 3} corresponds to <i>a</i>&times;<i>b</i>&times;<i>c</i> &divide;<i>d</i>. I use a closure to handle all permutations with repetition:</p>
                <code><pre>
auto nextOpCode = [&]() -&gt; bool {
&#9;for (int i = 0; i &lt; setSize-1; i++) {
&#9;&#9;if (++opCode[i] &gt;= numOpCodes) {
&#9;&#9;&#9;opCode[i] = 0;
&#9;&#9;&#9;if (i == setSize-2) return false;
&#9;&#9;} else break;
&#9;}
&#9;return true;
};</pre></code>
                <p>Finally, since there are only 5 different arrangements of parentheses, a simple <samp>for loop</samp> handles iteration:</p>
                <code><pre>
for (int pCode = 0; pCode &lt; numParenthesesCodes; pCode++) {
&#9;// all parentheses arrangements
}</pre></code>
                <h4>Putting it all together</h4>
                <p>Combining the above iteration methods, the final function finds the set of 4 numbers that produce the longest consecutive string of target numbers. The target numbers reachable by a given set are stored in <samp>solutions</samp>, a boolean array. The indices represent target numbers and a value of true at index <i>i</i> means <i>i</i> is a reachable target number.</p>
                <code><pre class="small-text">
#include &lt;string&gt;
#include &lt;array&gt;
#include &lt;algorithm&gt;

std::string longestSolutionSet() {
&#9;std::array&lt;bool, maxNumber+1&gt; mask = {};
&#9;std::fill(mask.begin()+1, mask.begin()+1+setSize, true);

&#9;opArray_t opCode = {};
&#9;auto nextOpCode = [&]() -&gt; bool {
&#9;&#9;for (int i = 0; i &lt; setSize-1; i++) {
&#9;&#9;&#9;if (++opCode[i] &gt;= numOpCodes) {
&#9;&#9;&#9;&#9;opCode[i] = 0;
&#9;&#9;&#9;&#9;if (i == setSize-2) return false;
&#9;&#9;&#9;} else break;
&#9;&#9;}
&#9;&#9;return true;
&#9;};

&#9;int longestSequence = 0;
&#9;setArray_t solutionSet;

&#9;do { // All sets of 4 numbers

&#9;&#9;setArray_t set;
&#9;&#9;for (int i = 1, n = 0; i &lt;= maxNumber; i++) // read mask
&#9;&#9;&#9;if (mask[i]) set[n++] = static_cast&lt;float&gt;(i);
&#9;&#9;std::array&lt;bool, maxSolution+1&gt; solutions = {};

&#9;&#9;// Generate all expressions possible with this set
&#9;&#9;do { // All permutations of this set
&#9;&#9;&#9;do { // All operator arrangements
&#9;&#9;&#9;&#9;for (int pCode = 0; pCode &lt; numParenthesesCodes; pCode++) {
&#9;&#9;&#9;&#9;&#9;// All parentheses arrangements
&#9;&#9;&#9;&#9;&#9;bool valid = true;
&#9;&#9;&#9;&#9;&#9;int result = evaluateExpression(set, opCode, pCode, valid);
&#9;&#9;&#9;&#9;&#9;if (valid && result &gt; 0 && !solutions[result]) 
&#9;&#9;&#9;&#9;&#9;&#9;solutions[result] = true;
&#9;&#9;&#9;&#9;}
&#9;&#9;&#9;} while (nextOpCode());
&#9;&#9;} while (std::next_permutation(set.begin(), set.end()));

&#9;&#9;// Check the number of consecutive target numbers
&#9;&#9;int sequenceLength = std::find(++solutions.begin(), solutions.end(), false) - solutions.begin() - 1;
&#9;&#9;if (sequenceLength &gt; longestSequence) {
&#9;&#9;&#9;longestSequence = sequenceLength;
&#9;&#9;&#9;solutionSet = set;
&#9;&#9;}

&#9;} while (std::prev_permutation(mask.begin()+1, mask.end()));

&#9;// Convert the solution set into a std::string
&#9;std::string result = "";
&#9;for (auto i : solutionSet) result += ('0' + static_cast&lt;int&gt;(i));

&#9;return result;
}</pre></code>
            </section>
            <section>
                <h2>Final Thoughts</h2>
                <p>On my Github page I added a couple extra functions not shown here that enable my program to print the expressions and target numbers of the problem's solution and also of sets input on the command line. The problem's entire solution found by my program is below.</p>
                <code><pre class="small-text">
1258 produces 51 consecutive solutions:
((1 + 2) + 5) / 8 = 1
(1 - (2 + 5)) + 8 = 2
((1 - 2) * 5) + 8 = 3
((1 + 5) * 2) - 8 = 4
((1 * 2) - 5) + 8 = 5
((1 + 2) - 5) + 8 = 6
((1 + 2) * 5) - 8 = 7
((1 - 5) + 8) * 2 = 8
((1 / 2) * 8) + 5 = 9
1 + (5 + (8 / 2)) = 10
((1 * 2) * 8) - 5 = 11
((1 - 2) + 5) + 8 = 12
((1 + 8) * 2) - 5 = 13
((2 - 1) + 5) + 8 = 14
((1 * 2) + 5) + 8 = 15
((1 + 2) + 5) + 8 = 16
((2 * 5) - 1) + 8 = 17
((1 * 2) * 5) + 8 = 18
(1 + (2 * 5)) + 8 = 19
((1 / 2) * 5) * 8 = 20
((1 * 2) * 8) + 5 = 21
(1 + (2 * 8)) + 5 = 22
((1 + 2) * 5) + 8 = 23
(1 - 5) * (2 - 8) = 24
1 - ((2 - 5) * 8) = 25
1 * (2 * (5 + 8)) = 26
1 + (2 * (5 + 8)) = 27
(1 + (5 / 2)) * 8 = 28
((1 + 2) * 8) + 5 = 29
1 * (5 * (8 - 2)) = 30
1 - ((2 - 8) * 5) = 31
((1 - 2) + 5) * 8 = 32
(5 * (8 - 1)) - 2 = 33
2 - ((1 - 5) * 8) = 34
((1 - 2) + 8) * 5 = 35
(1 + 5) * (8 - 2) = 36
2 - ((1 - 8) * 5) = 37
((1 * 5) * 8) - 2 = 38
(1 + 2) * (5 + 8) = 39
((2 - 1) * 5) * 8 = 40
(2 - 1) + (5 * 8) = 41
1 * (2 + (5 * 8)) = 42
1 + (2 + (5 * 8)) = 43
((1 / 2) + 5) * 8 = 44
((2 - 1) + 8) * 5 = 45
((1 + 5) * 8) - 2 = 46
((1 + 8) * 5) + 2 = 47
((2 - 1) + 5) * 8 = 48
(2 + 5) * (8 - 1) = 49
((1 * 2) + 8) * 5 = 50
1 + ((2 + 8) * 5) = 51</pre></code>
                <p>In solving this problem, I tried my best to generalize my solution as much as possible. The biggest challenge was finding a general way to handle the arrangements of parentheses. While the other variables to iterate were relatively simple, I found it out of the scope of this problem to implement a general algorithm for different parentheses. Therefore I hardcoded the different arrangements in <samp>evaluateExpression</samp> with a switch statement.</p>
                <p>A truly general solution would most likely require an entirely different way of representing expressions, perhaps using <a class="wiki-link-inline" href="https://en.wikipedia.org/wiki/Polish_notation" target="_blank">Polish notation</a> (and may be easier with a language other than C++!). For the interested reader I think it would make a fun challenge.</p>
            </section>

            <div id="end-page-links">
                <a href="/projects/euler-problems/91.html" id="prev-problem"><i class="fas fa-arrow-left"></i>&nbsp;Previous: Right triangles with integer coordinates</a>
                <a href="/projects/euler-problems/95.html" id="next-problem">Next: Amicable chains&nbsp;<i class="fas fa-arrow-right"></i></a>
            </div>
        </div>

        <div id="push"></div>
    </div>

    <!-- Footer -->
    <footer>
        <p>Website &copy; <span id="year">2020</span> Nathan Paternoster</p>
        <script>
            var d = new Date();
            document.getElementById("year").innerHTML = d.getFullYear();
        </script>
    </footer>
</body>
</html>