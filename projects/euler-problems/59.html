<!DOCTYPE html>

<html lang="en" xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta charset="utf-8" />
    <title>Nathan Paternoster | Contact</title>
    <link rel="icon" type="image/x-icon" href="/images/favicon.ico">
    <link rel="stylesheet" type="text/css" href="/css/nate.css" />
    <link rel="stylesheet" type="text/css" href="/css/projects.css" />
    <noscript><link rel="stylesheet" type="text/css" href="/css/no-js.css" /></noscript>
    <script src="/js/nate.js" defer></script>
    <script src="https://kit.fontawesome.com/254df2922f.js" crossorigin="anonymous"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
    <div id="page-wrapper">

        <!-- Top navigation bar -->
        <ul class="topnav">
            <li><a href="/index.html">Nathan Paternoster</a></li>
            <li><a href="/coursework.html">Coursework</a></li>
            <li><a href="/projects.html">Projects</a></li>
            <li><a href="/recordings.html">Recordings</a></li>
            <li><a href="/contact.html">Contact</a></li>
        </ul>

        <!-- Page content -->
        <div class="content">
            <div class="euler-problem-link-container">
                <a href="../euler.html" class="back-link"><i class="fas fa-arrow-left"></i>&nbsp;Back to Problems</a>
                <div class="euler-problem-links">
                    <a href="https://projecteuler.net/problem=59" target="_blank"><i class="fas fa-link"></i>&nbsp;Problem 59 on Project Euler</a>
                    <a href="https://github.com/n8paternoster/Project-Euler/blob/master/Project%20Euler/59.cpp" target="_blank"><i class="fas fa-code"></i>&nbsp;Problem 59 Code</a>
                </div>
            </div>
            <h1 id="euler-problem-title">Problem 59 - XOR decryption</h1>
            <div class="euler-problem-view">
                <button class="accordion" type="button"> <!--onclick="toggleAccordion(this)"-->View problem</button>
                <div class="accordion-panel">
                    <blockquote cite="https://projecteuler.net/problem=59">
                        <p>Each character on a computer is assigned a unique code and the preferred standard is ASCII (American Standard Code for Information Interchange). For example, uppercase A = 65, asterisk (*) = 42, and lowercase k = 107.</p>
                        <p>A modern encryption method is to take a text file, convert the bytes to ASCII, then XOR each byte with a given value, taken from a secret key. The advantage with the XOR function is that using the same encryption key on the cipher text, restores the plain text; for example, 65 XOR 42 = 107, then 107 XOR 42 = 65.</p>
                        <p>For unbreakable encryption, the key is the same length as the plain text message, and the key is made up of random bytes. The user would keep the encrypted message and the encryption key in different locations, and without both "halves", it is impossible to decrypt the message.</p>
                        <p>Unfortunately, this method is impractical for most users, so the modified method is to use a password as a key. If the password is shorter than the message, which is likely, the key is repeated cyclically throughout the message. The balance for this method is using a sufficiently long password key for security, but short enough to be memorable.</p>
                        <p>Your task has been made easy, as the encryption key consists of three lower case characters. Using p059_cipher.txt (right click and 'Save Link/Target As...'), a file containing the encrypted ASCII codes, and the knowledge that the plain text must contain common English words, decrypt the message and find the sum of the ASCII values in the original text.</p>
                    </blockquote>
                </div>
            </div>
            <hr />
            <section>
                <h2>XOR Ciphers</h2>
                <p>An XOR (exclusive-or) cipher is a common encryption technique where each character in a text is transformed using the XOR bitwise operator (&#8853;) and a key. In an XOR cipher, the XOR operator is used to transform a plaintext letter into its encrypted version. As a reminder, the XOR operator takes two binary inputs and outputs a 1 when the inputs are different and 0 when they are the same:
                </p>
                <img height="200" title="xor-truth-table" src="/project-assets/euler/xor-truth-table2.png"/>
                <p>When A and B are binary numbers, A &#8853; B is done bit-by-bit. For example:</p>
                <img title="xor-example" src="/project-assets/euler/bitwise-xor2.png"/>
                <p>In an XOR cipher, both the plaintext and key are written in binary and combined using the XOR operator to form the cipher: <i>plaintext</i> &#8853; <i>key</i> = <i>ciphertext</i>. Because it is an associative operator, we can also say <i>ciphertext</i> &#8853; <i>key</i> = <i>plaintext</i>. If we have the cipher and can figure out the key, we can recover the original message.</p>
                <p>As stated in the problem, when the key is as long as the plaintext, the encrypted ciphertext is unbreakable. Luckily we are given the information that the key is only 3 characters long and that all characters are lowercase letters. With 3 characters and 26 lowercase letters, there are 26<sup>3</sup> = 17,576 possible keys to try. It's easy enough to programatically generate all of these keys and the corresponding plaintext for each; but how will we know which one is correct? It's not practical to manually read every possible plaintext to find the correct one. Fortunately, there is a technique to programatically determine the correct key.</p>
            </section>
            <section> 
                <h2>Frequency Analysis</h2>
                <p>Frequency analysis leverages the fact that in any language, certain letters are used more often than others. In English, the top 5 most common letters are commonly given as E, T, A, O, and I (depending on the source used). If we examine the ciphertext and look for the most common letter, we can guess that that letter represents E in the plaintext. Continuing down the list of most common letters, we can keep making guesses until patterns or recognizable words start to emerge.</p>
                <p>While this is a popular method for pencil and paper solving, it has one main problem putting into use here - it still relies on guesswork. What we need is a way to quantitatively measure how likely any given substitution is.</p>
                <p>One method in cryptanalysis is to use the Chi-squared statistic to measure the probability of any given substitution. The Chi-squared statistic is given by:</p>
                <img height="75" title="chi-squared-formula" src="/project-assets/euler/chi-squared-formula.png"/>
                <p><i>O<sub>i</sub></i> is the count of occurences of the <i>i</i>th letter in a given distribution and <i>E<sub>i</sub></i> is the expected count of occurences of that letter. The closer the observed value <i>O<sub>i</sub></i> is to the expected value, the lower &chi;<sup>2</sup> will be and the more likely that letter follows the standard distribution of letters in the English language.</p>
            </section>
            <section>
                <h2>Implementation</h2>
                <p>Now that we have a way to determine the most likely key, we can start writing the functions needed to solve this problem. Since the &chi;<sup>2</sup> formula requires the expected and observed counts, we need a way to determine the expected counts.</p>
                <code><pre>
#include &lt;unordered_map&gt;
#include &lt;vector&gt;
#include &lt;fstream&gt;
#include &lt;cctype&gt;&#9;// isalpha, tolower
using Letter_Counts = std::unordered_map&lt;unsigned char, double&gt;;

Letter_Counts getExpected(unsigned dataLength) {
&#9;static unsigned char letters[26] = {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'};

&#9;static double freqs[26] = {.0855, .016, .0316, .0387, .121, .0218, .0209, .0496, .0733, .0022, .0081, .0421, .0253, .0717, .0747, .0207, .001, .0633, .0673, .0894, .0268, .0106, .0183, .0019, .0172, .0011};

&#9;Letter_Counts vals;
&#9;for (unsigned i = 0; i &lt; 26; i++)
&#9;&#9;vals.emplace(letters[i], (dataLength * freqs[i]));
&#9;return vals;
}               </pre></code>
                <p>The function <samp>getExpected</samp> accepts the number of letters in a given text as input and returns a map that contains the expected count of each individual letter (<i>E<sub>i</sub></i> in the above equation) using letter frequency data. For the function computing &chi;<sup>2</sup> we can use these expected counts in our computation.</p>
                <code><pre>
double chiSquared(std::vector&lt;unsigned char&gt; text) {

&#9;// count the observed frequency of letters
&#9;Letter_Counts observed;
&#9;unsigned numLetters = 0;
&#9;for (auto c : text) {
&#9;&#9;if (isalpha(c)) {
&#9;&#9;&#9;observed[tolower(c)]++;
&#9;&#9;&#9;numLetters++;
&#9;&#9;}
&#9;}
&#9;// calculate the expected frequency of letters
&#9;Letter_Counts expected = getExpected(numLetters);

&#9;// calculate the chi-squared value of the text
&#9;double chiSquared = 0.0;
&#9;for (unsigned char c = 'a'; c &lt;= 'z'; c++) {
&#9;&#9;double degree = (observed[c] - expected[c]) * (observed[c] - expected[c]) / expected[c];
&#9;&#9;chiSquared += degree;
&#9;}
&#9;return chiSquared;
}               </pre></code>
                <p><samp>chiSquared</samp> takes a  block of text as input (stored as a vector of characters) and returns the &chi;<sup>2</sup> value of that text. This value corresponds to how closely the input text matches the normal distribution of letters in the English language.</p>
                <p>With these two functions we can write the rest of the code to decrypt the cipher. We first read the cipher text into a vector container:</p>
                <code><pre>
std::vector&lt;unsigned char&gt; cipherText;
std::ifstream f(filename);
if (!f) {
&#9;std::cerr &lt;&lt; "Error opening cipher file\n";
&#9;return 0;
}
std::string s;
while (getline(f, s, ',')) cipherText.push_back(static_cast&lt;unsigned char&gt;(std::stoul(s)));
f.close();      </pre></code>
                <p>Because we know the key is 3 characters long, we know that every 3rd character in the cipher will be encrypted using the same character of the key (the key is repeated to cover the length of the entire plaintext). For this reason we can break the ciphertext into 3 vectors representing each "column" of the ciphertext.</p>
                <code><pre>
// key is 3 characters long, split the cipher into three columns
std::vector&lt;std::vector&lt;unsigned char&gt;&gt; cols(3);
int i = 0;
for (auto c : cipherText) {
&#9;cols[i].push_back(c);
&#9;if (++i &gt; 2) i = 0;
}               </pre></code>
                <p>With this data we can now calculate the key one character at a time. This can be done by trying every lowercase letter and choosing the one whose corresponding plaintext produces the lowest value of &chi;<sup>2</sup>.</p>
                <code><pre>
// each character of the key corresponds to one column of the cipher
unsigned char key[3] = {};
int k = 0;
for (auto col : cols) {
&#9;std::vector&lt;unsigned char&gt; plainCol;

&#9;// try each char for this col and select the one that produces plaintext that most closely matches the letter frequencies of the English language
&#9;double lowestChi = 1'000'000.0;
&#9;unsigned char keyChar;
&#9;for (char testChar = 'a'; testChar &lt;= 'z'; testChar++) {
&#9;&#9;plainCol.clear();
&#9;&#9;for (auto c : col) plainCol.push_back(static_cast&lt;unsigned char&gt;(c ^ testChar));
&#9;&#9;double chi = chiSquared(plainCol);
&#9;&#9;if (chi &lt; lowestChi) {
&#9;&#9;&#9;lowestChi = chi;
&#9;&#9;&#9;keyChar = testChar;
&#9;&#9;}
&#9;}

&#9;key[k] = keyChar;
&#9;k++;
}               </pre></code>
                <p>Finally, with this key, the original plaintext can be recovered and the result computed.</p>
                <code><pre>
std::vector&lt;unsigned char&gt; plainText;
k = 0;
for (auto c : cipherText) {
&#9;plainText.push_back(static_cast&lt;unsigned char&gt;(c ^ key[k]));
&#9;if (++k &gt; 2) k = 0;
}

// add the ascii values of the chars in the plaintext
unsigned result = 0;
for (auto c : plainText) result += c;</pre></code>
            </section>
            <section>
                <h2>Final Thoughts</h2>
                <p>Although the Chi-squared test is not a perfect way to decrypt any XOR cypher it was enough to solve this problem. With longer plaintexts there would be more certainty of the computed key and plaintext being correct. Improvements to this method could use more advanced techniques of frequency analysis that consider not only the most common letters in the English language, but also the most common pairs or larger groups of letters. For example, the letter Q is almost always followed by a U and the most common digraphs include TH, ER, ON, and AN.</p>
            </section>
        </div>

        <div id="push"></div>
    </div>

    <!-- Footer -->
    <footer>
        <p>Website &copy; <span id="year">2020</span> Nathan Paternoster</p>
        <script>
            var d = new Date();
            document.getElementById("year").innerHTML = d.getFullYear();
        </script>
    </footer>
</body>
</html>