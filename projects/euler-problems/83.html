<!DOCTYPE html>

<html lang="en" xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta charset="utf-8" />
    <title>Nathan Paternoster | Project Euler Problem 83</title>
    <link rel="icon" type="image/x-icon" href="/images/favicon.ico">
    <link rel="stylesheet" type="text/css" href="/css/nate.css" />
    <link rel="stylesheet" type="text/css" href="/css/projects.css" />
    <noscript><link rel="stylesheet" type="text/css" href="/css/no-js.css" /></noscript>
    <script src="/js/nate.js" defer></script>
    <script src="https://kit.fontawesome.com/254df2922f.js" crossorigin="anonymous"></script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
    <div id="page-wrapper">

        <!-- Top navigation bar -->
        <ul class="topnav">
            <li><a href="/index.html">Nathan Paternoster</a></li>
            <li><a href="/coursework.html">Coursework</a></li>
            <li><a href="/projects.html">Projects</a></li>
            <li><a href="/recordings.html">Recordings</a></li>
            <li><a href="/contact.html">Contact</a></li>
        </ul>

        <!-- Page content -->
        <div class="content">
            <div class="euler-problem-link-container">
                <a href="../euler.html" class="back-link"><i class="fas fa-arrow-left"></i>&nbsp;Back to Problems</a>
                <div class="euler-problem-links">
                    <a href="https://projecteuler.net/problem=83" target="_blank"><i class="fas fa-link"></i>&nbsp;Problem 83 on Project Euler</a>
                    <a href=""<!--GITHUB LINK--> target="_blank"><i class="fas fa-code"></i>&nbsp;Problem 83 Code</a>
                </div>
            </div>
            <h1 id="euler-problem-title">Problem 83 - Path sum: four ways</h1>
            <div class="euler-problem-view">
                <button class="accordion" type="button">View problem</button>
                <div class="accordion-panel">
                    <blockquote cite="https://projecteuler.net/problem=83">
                        <p>NOTE: This problem is a significantly more challenging version of Problem 81.</p>
                        <p>In the 5 by 5 matrix below, the minimal path sum from the top left to the bottom right, by moving left, right, up, and down, is indicated in bold red and is equal to 2297.</p>
                        <div>
                            $$
                            \begin{pmatrix}
                            \color{red}{131} &amp; 673 &amp; \color{red}{234} &amp; \color{red}{103} &amp; \color{red}{18}\\
                            \color{red}{201} &amp; \color{red}{96} &amp; \color{red}{342} &amp; 965 &amp; \color{red}{150}\\
                            630 &amp; 803 &amp; 746 &amp; \color{red}{422} &amp; \color{red}{111}\\
                            537 &amp; 699 &amp; 497 &amp; \color{red}{121} &amp; 956\\
                            805 &amp; 732 &amp; 524 &amp; \color{red}{37} &amp; \color{red}{331}
                            \end{pmatrix}
                            $$
                        </div>
                        <p>Find the minimal path sum from the top left to the bottom right by moving left, right, up, and down in matrix.txt (right click and "Save Link/Target As..."), a 31K text file containing an 80 by 80 matrix.</p>
                    </blockquote>
                </div>
            </div>
            <hr />
            <section>
                <h2>Modeling the Graph</h2>
                <p>This problem calls for a shortest-path algorithm. In order to choose one, consider the graph implied by the given matrix. We can think of the 80x80 matrix as a <i>weighted</i>, <i>directed</i> graph consisting of 80x80 = 6400 vertices. Because the problem allows movement to adjacent vertices (above, below, and to either side), each vertex (except edge vertices) will have 4 edges to 4 neighbors. The cost (or <i>weight</i>) associated with each edge is the integer value of the destination vertex. For this reason, the graph will have <i>directed</i> edges, as travel between 2 neighboring vertices will have different costs depending on which direction you travel.</p>
                <figure>
                    <img style="max-height: 250px" src="/project-assets/euler/matrix-graph.png" alt="Matrix modeled as a graph" />
                    <figcaption>The top left section of the graph</figcaption>
                </figure>
                <p>Since the problem specifies a single source vertex (top-left) and a single destination vertex (bottom-right), I chose Dijkstra's algorithm for its relative simplicity and acceptable time complexity. A faster algorithm, such as A*, could also be used. </p>
            </section>
            <section>
                <h2>Dijkstra's Shortest Path Algorithm</h2>
                <p><a class="wiki-link-inline" href="https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm" target="_blank">Dijkstra's algorithm</a> makes use of several data structures. A graph, <i>G</i>, represents a structure to store all of the vertices. An array, <i>D</i>, stores the tentative shortest distance between a vertex <i>v</i> and the starting vertex. A priority queue, <i>Q</i>, is typically used to process vertices. In some implementations, an array, <i>P</i>, can be used to store the previous vertex in the tentative shortest path for any vertex in the graph. This can then be reconstructed once the shortest path is found to show the steps of the path. I do not use this structure for this problem.</p>
                <p>The priority queue, <i>Q</i>, will hold vertices currently being processed and order them using their minimum distance in <i>D</i>. The vertex with the lowest distance recorded in <i>D</i> will have the highest priority and be placed at the front of the queue.</p>
                <code><pre>
(1) Initialize:
&#9;&#9;D[n] = INFINITY for every vertex n in G
&#9;&#9;D[source] = 0
(2) Add source vertex to Q
(3) Remove the minimum vertex, u, from Q
(4) If (u == destination) go to (7)
(5) For each neighbor v of u
&#9;(i) alt = D[u] + cost(v)
&#9;(ii) if (alt &lt; D[v])
&#9;&#9;&#9;D[v] = alt
&#9;&#9;&#9;Add v to Q
(6) If Q is not empty go to (3)
(7) Return D[destination]</pre></code>
            </section>
            <section>
                <h2>Implementation</h2>
                <p>The graph of vertices, <i>G</i>, will be stored in a one-dimensional array where the index of each vertex will correspond to its row and column within the matrix using the following formula:</p>
                <code><pre>
index = row*(total # rows) + column</pre></code>
                <p>For example, the cell marked 956 in the problem will have an index of 3*80 + 4 = 244 and a value of 956. The value of G[v] for vertex <i>v</i> will also correspond to the cost to travel to <i>v</i> from any of its neighbors.</p>
                <p>First, a function to read the text file into <i>G</i>:</p>
                <code><pre>
#include &lt;string&gt;
#include &lt;sstream&gt;
#include &lt;fstream&gt;

void readMatrix(std::string file, int *G, const int N) {
&#9;std::ifstream f(file);
&#9;if (!f) {
&#9;&#9;std::cerr << "Error opening file";
&#9;&#9;return;
&#9;}
&#9;for (int x = 0; x &lt; N; x++) {
&#9;&#9;// Rows separated by '\n'
&#9;&#9;std::string buff;
&#9;&#9;f &gt;&gt; buff;
&#9;&#9;std::stringstream row(buff);
&#9;&#9;for (int y = 0; y &lt; N; y++) {
&#9;&#9;&#9;// Cols separated by ','
&#9;&#9;&#9;std::string val;
&#9;&#9;&#9;std::getline(row, val, ',');
&#9;&#9;&#9;G[x*N+y] = std::stoi(val);
&#9;&#9;}
&#9;}
}</pre></code>
                <p>Next, a function implementing Dijkstra's algorithm described above:</p>
                <code><pre>
#include &lt;queue&gt;	// std::priority_queue

int dijkstraFourWays(int source, int destination, int *cost, const int N) {

&#9;// Distance to each node from the source node
&#9;int *dist = new int[N*N]();
&#9;for (int i = 0; i &lt; N*N; i++)
&#9;&#9;dist[i] = INT_MAX;
&#9;dist[source] = cost[source];	// source node

&#9;// Min-priority queue with custom comparison fnc
&#9;auto comp = [&dist](int lhs, int rhs) -&gt; bool {
&#9;&#9;return dist[lhs] &gt; dist[rhs];
&#9;};
&#9;std::priority_queue&lt;int, std::vector&lt;int&gt;, decltype(comp)&gt; Q(comp);

&#9;Q.push(source);
&#9;while (!Q.empty()) {
&#9;&#9;int u = Q.top();
&#9;&#9;Q.pop();
&#9;&#9;if (u == destination) break;
&#9;&#9;int row = u / N, col = u % N;
&#9;&#9;int neighbors[4] = {col+1 &lt; N ? u+1 : -1,	// right
&#9;&#9;&#9;&#9;&#9;&#9;&#9;col-1 &gt;= 0 ? u-1 : -1,	// left
&#9;&#9;&#9;&#9;&#9;&#9;&#9;row+1 &lt; N ? u+N : -1,	// bottom
&#9;&#9;&#9;&#9;&#9;&#9;&#9;row-1 &gt;= 0 ? u-N : -1};	// top
&#9;&#9;for (int i = 0; i &lt; 4; i++) {
&#9;&#9;&#9;int v = neighbors[i];
&#9;&#9;&#9;if (v != -1) {
&#9;&#9;&#9;&#9;int alt = dist[u] + cost[v];
&#9;&#9;&#9;&#9;if (alt &lt; dist[v]) {
&#9;&#9;&#9;&#9;&#9;dist[v] = alt;
&#9;&#9;&#9;&#9;&#9;Q.push(v);
&#9;&#9;&#9;&#9;}
&#9;&#9;&#9;}
&#9;&#9;}
&#9;}
&#9;int result = dist[destination];
&#9;delete[] dist;
&#9;return result;
}</pre></code>
                <p>The arguments <samp>source</samp> and <samp>destination</samp> are the indices of the source and destination vertices. <samp>cost</samp> is the graph, <i>G</i>, as described above. <samp>N</samp> is the size of the matrix, in this problem, 80. <samp>dist</samp> is the array, <i>D</i>, of shortest distances described above.</p>
                <p>I use the C++ std::priority_queue with a custom comparator lambda that compares the shortest distances using <samp>dist</samp>. I find the indices of the 4 neighbors of each vertex by using simple arithmetic between indices. A value of <samp>-1</samp> is used if vertex <samp>u</samp> is on the edge of the graph and doesn't have that specific neighbor.</p>
                <p>Finally, the driver function to find the shortest path:</p>
                <code><pre>
int shortestPath(std::string file, const int N) {

&#9;// Read the data
&#9;int *graph = new int[N*N]();
&#9;readMatrix(file, graph, N);

&#9;// Find the shortest path from top left (0, 0) to bottom right (N-1, N-1)
&#9;int result = dijkstraFourWays(0, N*N-1, graph, N);

&#9;delete[] graph;
&#9;return result;
}</pre></code>
            </section>
            <div id="end-page-links">
                <a href="/projects/euler-problems/76.html" id="prev-problem"><i class="fas fa-arrow-left"></i>&nbsp;Previous: Counting summations</a>
                <a href="/projects/euler-problems/89.html" id="next-problem">Next: Roman numerals&nbsp;<i class="fas fa-arrow-right"></i></a>
            </div>
        </div>

        <div id="push"></div>
    </div>

    <!-- Footer -->
    <footer>
        <p>Website &copy; <span id="year">2020</span> Nathan Paternoster</p>
        <script>
            var d = new Date();
            document.getElementById("year").innerHTML = d.getFullYear();
        </script>
    </footer>
</body>
</html>