--16-bit Calculator

library ieee;
use ieee.std_logic_unsigned.all;
use ieee.std_logic_1164.all;

entity sixteenbitcalculator is
	port(X, Y : in std_logic_vector(15 downto 0);
	      clk : in std_logic;
	load, ctr : in std_logic_vector(3 downto 0);
	      OPC : in std_logic_vector(4 downto 0);
	   output : out std_logic_vector(3 downto 0));
end entity;

architecture structural of sixteenbitcalculator is
	component fourbitreg
		port(input : in std_logic_vector(3 downto 0); 
		 clk, load : in std_logic;
		    output : out std_logic_vector(3 downto 0));
	end component;
	component fourbitbuffer
		port(data : in std_logic_vector(3 downto 0); 
		      ctr : in std_logic;
		   output : out std_logic_vector(3 downto 0));
	end component;
	signal result : std_logic_vector(15 downto 0);
	signal regout : std_logic_vector(15 downto 0); 
begin
	calculatorprocess: process(X, Y, OPC)
	begin
		if (OPC = "10000") then
			if (Y = "0") then
				result <= "0000000000000000";
			else
				result <= Y;
			end if;
		elsif (OPC = "10001") then
			if (Y = "0") then
				result <= "0000000000000001";
			else
				result <= Y + "1";
			end if;
		elsif (OPC = "10011") then
			if (Y = "0") then
				result <= X;
			else
				result <= X + Y;
			end if;
		elsif (OPC = "10100") then
			result <= NOT Y;
		elsif (OPC = "10101") then
			result <= "0" - Y;
		elsif (OPC = "10111") then
			result <= Y - X;
		elsif (OPC = "11000") then
			if (Y = "0") then
				result <= "1000000000000000";
			else
				result <= Y - "1";
			end if;
		elsif (OPC = "11001") then
			result <= X - Y;
		elsif (OPC = "11011") then
			result <= NOT X;
		elsif (OPC = "11100") then
			result <= X AND Y;
		elsif (OPC = "11101") then
			result <= X OR Y;
		elsif (OPC = "11110") then
			result <= X XOR Y;
		end if;
	end process;

	Reg0 : fourbitreg port map(result(3 downto 0), clk, load(0), regout(3 downto 0));
	Reg1 : fourbitreg port map(result(7 downto 4), clk, load(1), regout(7 downto 4));
	Reg2 : fourbitreg port map(result(11 downto 8), clk, load(2), regout(11 downto 8));
	Reg3 : fourbitreg port map(result(15 downto 12), clk, load(3), regout(15 downto 12));

	Buff0 : fourbitbuffer port map(regout(3 downto 0), ctr(0), output);
	Buff1 : fourbitbuffer port map(regout(7 downto 4), ctr(1), output);
	Buff2 : fourbitbuffer port map(regout(11 downto 8), ctr(2), output);
	Buff3 : fourbitbuffer port map(regout(15 downto 12), ctr(3), output);

end architecture;






--4-bit Register Component

library ieee;
use ieee.std_logic_unsigned.all;
use ieee.std_logic_1164.all;

entity fourbitreg is
	port(input : in std_logic_vector(3 downto 0);
	 clk, load : in std_logic;
	    output : out std_logic_vector(3 downto 0));
end entity;

architecture algorithmic of fourbitreg is
	signal storage : std_logic_vector(3 downto 0);
begin
	regprocess: process(clk)
	begin
		if (clk'event and clk = '1' and load = '1') then
			storage <= input;
		elsif (clk'event and clk = '0') then
			output <= storage;
		end if;
	end process;
end architecture;



--4-bit Tri-State Buffer Component

library ieee;
use ieee.std_logic_unsigned.all;
use ieee.std_logic_1164.all;

entity fourbitbuffer is
	port(data : in std_logic_vector(3 downto 0);
	      ctr : in std_logic;
	   output : out std_logic_vector(3 downto 0));
end entity;

architecture algorithmic of fourbitbuffer is
begin
	buffprocess: process(ctr)
	begin
		if (ctr = '1') then
			output <= data;
		elsif (ctr = '0') then
			output <= "ZZZZ";
		end if;
	end process;
end architecture;